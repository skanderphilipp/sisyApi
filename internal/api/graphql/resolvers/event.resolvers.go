package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"

	"github.com/blnto/blnto_service/internal/domain/models"
	"github.com/blnto/blnto_service/internal/utils"
	"github.com/google/uuid"
)

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input models.CreateEventInput) (*models.Event, error) {
	panic(fmt.Errorf("not implemented: CreateEvent - createEvent"))
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, input models.DeleteEventInput) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEvent - deleteEvent"))
}

// ListEvents is the resolver for the listEvents field.
func (r *queryResolver) ListEvents(ctx context.Context, first *int, after *string, last *int, before *string) (*models.EventConnection, error) {
	events, nextCursor, limit, err := utils.FetchItemsList[models.Event](ctx, first, after, r.eventService.FindAllUpcoming)
	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, nextCursor, cursorFunc)

	return eventConnection, nil
}

// GetEvent is the resolver for the getEvent field.
func (r *queryResolver) GetEvent(ctx context.Context, id uuid.UUID) (*models.Event, error) {
	panic(fmt.Errorf("not implemented: GetEvent - getEvent"))
}

// GetUpcomingEventsByVenue is the resolver for the getUpcomingEventsByVenue field.
func (r *queryResolver) GetUpcomingEventsByVenue(ctx context.Context, venueID uuid.UUID) (*models.EventConnection, error) {
	limit := 50
	events, err := r.eventService.FindUpcomingByVenueID(ctx, venueID)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}

// GetPastEventsByVenue is the resolver for the getPastEventsByVenue field.
func (r *queryResolver) GetPastEventsByVenue(ctx context.Context, venueID uuid.UUID) (*models.EventConnection, error) {
	limit := 50
	events, err := r.eventService.FindPastEventsByVenueID(ctx, venueID)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}

// GetAllUpcomingEvents is the resolver for the getAllUpcomingEvents field.
func (r *queryResolver) GetAllUpcomingEvents(ctx context.Context) (*models.EventConnection, error) {
	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}
	limit := 100

	events, nextCursor, limit, err := utils.FetchItemsList[models.Event](ctx, &limit, nil, r.eventService.FindAllUpcoming)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	eventConnection := utils.BuildEventConnection(events, limit, nextCursor, cursorFunc)

	return eventConnection, nil
}

// GetTodayEvents is the resolver for the getTodayEvents field.
func (r *queryResolver) GetTodayEvents(ctx context.Context) (*models.EventConnection, error) {
	limit := 100
	events, err := r.eventService.FindToday(ctx)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}

// GetTommorowEvents is the resolver for the getTommorowEvents field.
func (r *queryResolver) GetTommorowEvents(ctx context.Context) (*models.EventConnection, error) {
	limit := 50
	events, err := r.eventService.FindTomorrow(ctx)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}

// GetCurrentEvents is the resolver for the getCurrentEvents field.
func (r *queryResolver) GetCurrentEvents(ctx context.Context) (*models.EventConnection, error) {
	limit := 50
	events, err := r.eventService.FindCurrent(ctx)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}

// GetEventsByVenue is the resolver for the getEventsByVenue field.
func (r *queryResolver) GetEventsByVenue(ctx context.Context, venueID uuid.UUID) (*models.EventConnection, error) {
	limit := 50
	events, err := r.eventService.FindUpcomingByVenueID(ctx, venueID)

	if err != nil {
		return nil, fmt.Errorf("error fetching artists: %v", err)
	}

	cursorFunc := func(event *models.Event) string {
		return event.ID.String()
	}

	eventConnection := utils.BuildEventConnection(events, limit, "", cursorFunc)

	return eventConnection, nil
}
